Why can you not acquire new locks after releasing locks?

Strict 2PL
- acquire more and more locks and release all at once

2PL
- allowed to gradually release locks (but require all locks at once)?

Serializability is the good property of a schedule

Types of schedules
	Serial
	Equivalent
	Serializable
Anomalies:
Reading uncommitted reads
	Read a value written from a transaction that later aborts
Unrepeatable reads
	Two consecutive reads in a transaction are different
Write-Write
	Overwriting uncommitted data

Conflict serializeable:
Conflict equivalent
	- Transactions consisting of same actions
	- Two actions are in conflict if they are in two transactions and one is a write
Non conflict serializable - cannot reorder??
Conflict serializable - only if its precedence graph is acyclic
	- 2pl only allows this schedule
	
Question solution:
	T2 -> T1, T3->T1, T3->T2
	T2 -> T1, T1 -> T3, T3 -> T2

Some schedules might be serializable but that are not conflict serializable.

View serializability:
Not guaranteed that the serializble schedule will read the same initial value


Deadlock prevention
	Wait-die - wait for lower priority transaction to finnish or die
	Woundwait - Ti aborts Tj, otherwise Ti waits (Ti has lower priority)
Deadlock detection
	Create waits-graph.
	Check for cycle in graph - then there is a deadlock
	
Optimistic concurrency control
	Read - Copy of data and make local changes
	Validate - validate the local changes for conflict
	Write - write the local changes to make them global
	
	Every transaction is given a timestamp - timestamp are after "read state"
	Forall Ti < Tj:
	Test1:
		Ti completes completely before Tj starts
	Test2:
		Ti completes before Tj starts write-phase and Ti does not write anything that Tj reads
		(non overlapping write and read set)
	Tests3:
		WriteSet(Ti) intersection ReadSet(Tj) = Ø
		WriteSet(Ti) intersection WriteSet(Tj) = Ø
	
	Overheead
		Which objects have been read and are written - more book keeping
		Check for conflicts during validation
		Write values two times (to local and to database)
		Restarts a lot a exclusive actions
		
	
Snapshot isolation
	Transactions see database as beginning of transaction
	If conflicting writes - abort (first comitter wins)
	
Phantom problem????

Exercises:
	T2 -> T1, T2->T3, T1->T3
	It is conflict serializable
	Could not have been generated by  a S2PL scheme
	
	Yes between z and x, Yes for X, No
	T2 -> T1, T3 -> T1

	ACID
		Atomicity
		Consistency
		Isolation
		Durability
	No cascading aborts og S2PL
	Yes
	
